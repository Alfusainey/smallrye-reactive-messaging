= MQTT

You have two options here:

1. you can connect to an MQTT broker or server as a source or sink. The MQTT support is based on
the https://vertx.io/docs/vertx-mqtt/java/#_vert_x_mqtt_client[Vert.x MQTT Client].
2. you can receive MQTT messages as an MQTT server. The MQTT support is based on the
https://vertx.io/docs/vertx-mqtt/java/#_vert_x_mqtt_server[Vert.x MQTT Server]

== MQTT server

For if you want your code to act as an MQTT server to receive MQTT messages from one or more
clients.

WARNING: This isn't a fully featured MQTT server, it will only handle publish requests and their
acknowledgment (for QoS 1 & 2). It will ignore subscription requests for instance.

NOTE: The server has no persistence, if no subscribers are listening, messages will be dropped.

=== Dependency

To enable the MQTT server support, you need the following dependency:

[source,xml,subs=attributes+]
----
<dependency>
  <groupId>io.smallrye.reactive</groupId>
  <artifactId>smallrye-reactive-messaging-mqtt-server</artifactId>
  <version>{project-version}</version>
</dependency>
----

=== Receive MQTT messages from one or more MQTT client

[source]
----
# [Source - messages] - Receive MQTT messages
# Required
mp.messaging.incoming.messages.connector=smallrye-mqtt-server

#mp.messaging.incoming.messages.host=0.0.0.0
#mp.messaging.incoming.messages.port=1883
# If clientid should be auto-generated when it's "zero-bytes"
#mp.messaging.incoming.messages.auto-client-id=true
# Max MQTT message size (variable header + payload)
#mp.messaging.incoming.messages.max-message-size=-1
# The timeout on CONNECT packet
#mp.messaging.incoming.messages.timeout-on-connect=90
# The TCP receive buffer size
#mp.messaging.incoming.messages.receive-buffer-size=-1
# [/Source - messages]
----

Message coming from MQTT are `Message<byte[]>`. The payload is a `byte[]`. You can also receive
`io.smallrye.reactive.messaging.mqtt.server.MqttMessage` which give you access to message metadata.

